
#include <ESP32Servo360.h>      // Servo
#include <ESP32Servo.h>         // ESC
#include <ESC.h>                // ESC
//#include <HardwareSerial.h>     // Serial Communication

// Servo Left = Servo 1
#define servoL_controlPin 32    // Control pin = white cable
#define servoL_feedbackPin 35   // Feedback pin = yellow cable

// Servo Right = Servo 2
#define servoR_controlPin 26
#define servoR_feedbackPin 34

// Servo Middle = Servo 3
#define servoM_controlPin 13
#define servoM_feedbackPin 14

// ESCs
#define escL_pin 25
#define escR_pin 33
#define escM_pin 27

// Serial
#define RXp2 16
#define TXp2 17


// Minimum & Maximum Rotation Speed for BLDC Motors
#define STOP_SPEED 1000
#define MIN_SPEED 1140
#define MAX_SPEED 1500


// Prototype Parameters
#define l1x -116.53             // Position in x of servo 1 - x is the longitudinal direction
#define l1y -54.5               // Position in y of servo 1 - y is the transversal direction
#define l2x -116.53
#define l2y 54.5
#define l3x 101.47
#define l3y 0

// Desired Generalized Forces
float Fx;                       // Generalized force in x
float Fy;
float Tz;

// Cartesian Actuator Forces
float F1x;                      // Force generated by azimuth thruster 1 in x-direction
float F1y;
float F2x;
float F2y;
float F3x;
float F3y;

// Actual Thrust & Azimuth Angle
float thrust1;                  // Thrust generated by BLDC motor 1
float thrust2;
float thrust3;
float theta1;                   // Azimuth angle set by servo 1
float theta2;
float theta3;

// Pulse Width to be sent to BLDC Motors
float pulseWidth1;
float pulseWidth2;
float pulseWidth3;


// Serial Message
String myS;
String Fx_string;
String Fy_string;
String Tz_string;


// Measured Angles from Servo's Feedback Signals
float angleL, angleR, angleM;
float orientationL, orientationR, orientationM;
int turns;


// Servo Objects
ESP32Servo360 servoL, servoR, servoM;

// ESC Objects
ESC escL(escL_pin,1000,2000,500); // ESC_Name(PIN, Minimum Value, Maximum Value, Arm Value)
ESC escR(escR_pin,1000,2000,500);
ESC escM(escM_pin,1000,2000,500);

// Serial Port
//HardwareSerial SerialPort(2); // use UART2


String getValueS(String data, char separator, int index) {
    int found = 0;
    int strIndex[] = {0, -1};
    int maxIndex = data.length()-1;

    for ( int i=0; i<=maxIndex and found<=index; i++) {
        if ( data.charAt(i)==separator or i==maxIndex) {
            found++;
            strIndex[0] = strIndex[1] + 1;
            strIndex[1] = (i == maxIndex) ? i+1 : i;
        }
    }
    
    return found>index ? data.substring(strIndex[0], strIndex[1]) : "";
}


void setup() {
    Serial.begin(115200);
//    SerialPort.begin(115200, SERIAL_8N1, RXp2, TXp2);
    delay(2000);

    pinMode(servoL_controlPin,OUTPUT);
    pinMode(servoR_controlPin,OUTPUT);
    pinMode(servoM_controlPin,OUTPUT);
    pinMode(servoL_feedbackPin,INPUT);
    pinMode(servoR_feedbackPin,INPUT);
    pinMode(servoM_feedbackPin,INPUT);

    pinMode(escL_pin,OUTPUT);
    pinMode(escR_pin,OUTPUT);
    pinMode(escM_pin,OUTPUT);
    
    servoL.attach(servoL_controlPin,servoL_feedbackPin);
    servoR.attach(servoR_controlPin,servoR_feedbackPin);
    servoM.attach(servoM_controlPin,servoM_feedbackPin);

    servoL.setSpeed(140);
    servoR.setSpeed(140);
    servoM.setSpeed(140);

    // Define offset in angular position (if required)
    servoL.setOffset(0);
    servoR.setOffset(0);
    servoM.setOffset(0);

    // Initiate servo angles
    servoL.rotateTo(0);
    servoR.rotateTo(0);
    servoM.rotateTo(0);

    // Wait for rotation
    servoL.wait();
    servoR.wait();
    servoM.wait();
    Serial.println("Waiting...");

    escL.arm();
    escR.arm();
    escM.arm();
    delay(15000);

    Serial.println("Setup DONE"); Serial.println("[APP] Free memory: " + String(esp_get_free_heap_size()) + " bytes");

    // Wait some time before starting
//    delay(5000);
}


int i = 0;
int Fx_vec[] = {0,1,0};
int Fy_vec[] = {1,0,0};
int Tz_vec[] = {0,0,1};

void loop() {
    delay(5000);

    // Stop and hold servos in their current angle
    servoL.hold();
    servoR.hold();
    servoM.hold();

//    // Send message via serial port
//    SerialPort.print("S");
//    SerialPort.print(theta1);
//    SerialPort.print(",");
//    SerialPort.print(theta2);

    // Define desired generalized forces & torques
//    Fx = 0;
//    Fy = 10;
//    Tz = 0;
    Fx = Fx_vec[i%3];
    Fy = Fy_vec[i%3];
    Tz = Tz_vec[i%3];
    i++;

    // CONTROL ALLOCATION
    // Calculate cartesian forces - mathematical expressions are pre-computed in MATLAB
    F1x = Fx/3 + (13159*Fy)/207100 + (3*Tz)/2071;
    F1y = (12872*Fy)/51775 - (4*Tz)/2071;
    F2x = Fx/3 - (13159*Fy)/207100 - (3*Tz)/2071;
    F2y = (12872*Fy)/51775 - (4*Tz)/2071;
    F3x = Fx/3;
    F3y = (26031*Fy)/51775 + (8*Tz)/2071;

    // Convert into thrusts & azimuth angles
    thrust1 = sqrt( F1x*F1x + F1y*F1y );
    thrust2 = sqrt( F2x*F2x + F2y*F2y );
    thrust3 = sqrt( F3x*F3x + F3y*F3y );
    theta1 = atan2( F1y, F1x ) * 4068/71;
    theta2 = atan2( F2y, F2x ) * 4068/71;
    theta3 = atan2( F3y, F3x ) * 4068/71;

    // Convert thrusts into commands
    pulseWidth1 = thrust2command(thrust1);
    pulseWidth2 = thrust2command(thrust2);
    pulseWidth3 = thrust2command(thrust3);

    // Release servos from their hold state
    servoL.release();
    servoR.release();
    servoM.release();

    // Give new thrusts and angular positions
    servoL.rotateTo(theta1);
    servoR.rotateTo(theta2);
    servoM.rotateTo(theta3);
//    escL.speed(pulseWidth1);
//    escR.speed(pulseWidth2);
//    escM.speed(pulseWidth3);

    // Wait for rotation
    servoL.wait();
    servoR.wait();
    servoM.wait();
    
    // Get angles measured by servo's feedback
    angleL = servoL.getAngle();
    angleR = servoR.getAngle();
    angleM = servoM.getAngle();

    // Print measured angles, then calculated angles (from control allocation)
    Serial.println((String)angleL + "\t" + angleR + "\t" + angleM + "\t" + theta1 + "\t" + theta2 + "\t" + theta3);
//    Serial.println((String)pulseWidth1 + "\t" + pulseWidth2 + "\t" + pulseWidth3);
//    Serial.println("[APP] Free memory: " + String(esp_get_free_heap_size()) + " bytes");
}


float thrust2command(float thrust) {
    float pulseWidth = ( thrust + 1.6266 ) / 0.0017;

    if ( pulseWidth < MIN_SPEED ) {
        pulseWidth = STOP_SPEED;
    }
    if ( pulseWidth > MAX_SPEED ) {
        pulseWidth = MAX_SPEED;
    }

    return pulseWidth;
}
